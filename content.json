{"meta":{"title":"Bear Love Honey","subtitle":null,"description":null,"author":"bearcandy","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"面向对象编程-this 关键字","slug":"面向对象编程-this-关键字","date":"2016-10-07T02:27:00.000Z","updated":"2017-03-06T09:21:09.467Z","comments":true,"path":"2016/10/07/面向对象编程-this-关键字/","link":"","permalink":"http://yoursite.com/2016/10/07/面向对象编程-this-关键字/","excerpt":"目录 涵义 使用场合 使用注意点 绑定 this 的方法 function.prototype.call() function.prototype.apply() function.prototype.bind() 参考链接1.涵义this关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。 首先，this总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象。1this.property 上面代码中，this就代表property属性当前所在的对象。","text":"目录 涵义 使用场合 使用注意点 绑定 this 的方法 function.prototype.call() function.prototype.apply() function.prototype.bind() 参考链接1.涵义this关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。 首先，this总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象。1this.property 上面代码中，this就代表property属性当前所在的对象。下面是一个实际的例子。123456789var person = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;person.describe()// &quot;姓名：张三&quot; 上面代码中，this.name表示describe方法所在的当前对象的name属性。调用person.describe方法时，describe方法所在的当前对象是person，所以就是调用person.name。 由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。1234567891011121314var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;B.describe = A.describe;B.describe()// &quot;姓名：李四&quot; 上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。 稍稍重构这个例子，this的动态指向就能看得更清楚。12345678910111213141516function f() &#123; return &apos;姓名：&apos;+ this.name;&#125;var A = &#123; name: &apos;张三&apos;, describe: f&#125;;var B = &#123; name: &apos;李四&apos;, describe: f&#125;;A.describe() // &quot;姓名：张三&quot;B.describe() // &quot;姓名：李四&quot; 上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。 只要函数被赋给另一个变量，this的指向就会变。12345678910var A = &#123; name: &apos;张三&apos;, describe: function () &#123; return &apos;姓名：&apos;+ this.name; &#125;&#125;;var name = &apos;李四&apos;;var f = A.describe;f() // &quot;姓名：李四&quot; 上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。 再看一个网页编程的例子。12345678&lt;input type=&quot;text&quot; name=&quot;age&quot; size=3 onChange=&quot;validate(this, 18, 99);&quot;&gt;&lt;script&gt;function validate(obj, lowval, hival)&#123; if ((obj.value &lt; lowval) || (obj.value &gt; hival)) console.log(&apos;Invalid Value!&apos;);&#125;&lt;/script&gt; 上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数，验证这个值是否在指定范围。回调函数传入this，就代表传入当前对象（即文本框），然后就可以从this.value上面读到用户的输入值。 总结一下，JavaScript语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。这本来并不会让用户糊涂，但是JavaScript支持运行环境动态切换，也就是说，this的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。 如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。12345function f() &#123; return this;&#125;f() === window // true 上面代码中，函数f在全局环境运行，它内部的this就指向顶层对象window。 可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 2.使用场合this的使用可以分成以下几个场合。 （1）全局环境 在全局环境使用this，它指的就是顶层对象window。12345this === window // truefunction f() &#123; console.log(this === window); // true&#125; 上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。 （2）构造函数 构造函数中的this，指的是实例对象。1234567var Obj = function (p) &#123; this.p = p;&#125;;Obj.prototype.m = function() &#123; return this.p;&#125;; 上面代码定义了一个构造函数Obj。由于this指向实例对象，所以在构造函数内部定义this.p，就相当于定义实例对象有一个p属性；然后m方法可以返回这个p属性。1234var o = new Obj(&apos;Hello World!&apos;);o.p // &quot;Hello World!&quot;o.m() // &quot;Hello World!&quot; （3）对象的方法 当A对象的方法被赋予B对象，该方法中的this就从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。 请看下面的代码。1234567var obj =&#123; foo: function () &#123; console.log(this); &#125;&#125;;obj.foo() // obj 上面代码中，obj.foo方法执行时，它内部的this指向obj。 但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。12345678// 情况一(obj.foo = obj.foo)() // window// 情况二(false || obj.foo)() // window// 情况三(1, obj.foo)() // window 上面代码中，obj.foo先运算再执行，即使它的值根本没有变化，this也不再指向obj了。 可以这样理解，在JavaScript引擎内部，obj和obj.foo储存在两个内存地址，简称为M1和M2。只有obj.foo()这样调用时，是从M1调用M2，因此this指向obj。但是，上面三种情况，都是直接取出M2进行运算，然后就在全局环境执行运算结果（还是M2），因此this指向全局环境。 上面三种情况等同于下面的代码。1234567891011121314// 情况一(obj.foo = function () &#123; console.log(this);&#125;)()// 情况二(false || function () &#123; console.log(this);&#125;)()// 情况三(1, function () &#123; console.log(this);&#125;)() 同样的，如果某个方法位于多层对象的内部，这时为了简化书写，把该方法赋值给一个变量，往往会得到意料之外的结果。1234567891011var a = &#123; b: &#123; m: function() &#123; console.log(this.p); &#125;, p: &apos;Hello&apos; &#125;&#125;;var hello = a.b.m;hello() // undefined 上面代码中，m是多层对象内部的一个方法。为求简便，将其赋值给hello变量，结果调用时，this指向了顶层对象。为了避免这个问题，可以只将m所在的对象赋值给hello，这样调用时，this的指向就不会变。12var hello = a.b;hello.m() // Hello （4）Node 在Node中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。12345// 全局环境this === global // true// 模块环境this === module.exports // true 3.使用注意点（1）避免多层this 由于this的指向是不确定的，所以切勿在函数中包含多层的this。123456789101112var o = &#123; f1: function () &#123; console.log(this); var f2 = function () &#123; console.log(this); &#125;(); &#125;&#125;o.f1()// Object// Window 上面代码包含两层this，结果运行后，第一层指向该对象，第二层指向全局对象。实际执行的是下面的代码。12345678910var temp = function () &#123; console.log(this);&#125;;var o = &#123; f1: function () &#123; console.log(this); var f2 = temp(); &#125;&#125; 一个解决方法是在第二层改用一个指向外层this的变量。12345678910111213var o = &#123; f1: function() &#123; console.log(this); var that = this; var f2 = function() &#123; console.log(that); &#125;(); &#125;&#125;o.f1()// Object// Object 上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。 事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，有大量应用，请务必掌握。 JavaScript 提供了严格模式，也可以硬性避免这种问题。在严格模式下，如果函数内部的this指向顶层对象，就会报错。12345678910var counter = &#123; count: 0&#125;;counter.inc = function () &#123; &apos;use strict&apos;; this.count++&#125;;var f = counter.inc;f()// TypeError: Cannot read property &apos;count&apos; of undefined 上面代码中，inc方法通过’use strict’声明采用严格模式，这时内部的this一旦指向顶层对象，就会报错。 （2）避免数组处理方法中的this 数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;); &#125;&#125;o.f()// undefined a1// undefined a2 上面代码中，foreach方法的回调函数中的this，其实是指向window对象，因此取不到o.v的值。原因跟上一段的多层this是一样的，就是内层的this不指向外部，而指向顶层对象。 解决这个问题的一种方法，是使用中间变量。1234567891011121314var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; var that = this; this.p.forEach(function (item) &#123; console.log(that.v+&apos; &apos;+item); &#125;); &#125;&#125;o.f()// hello a1// hello a2 另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。12345678910111213var o = &#123; v: &apos;hello&apos;, p: [ &apos;a1&apos;, &apos;a2&apos; ], f: function f() &#123; this.p.forEach(function (item) &#123; console.log(this.v + &apos; &apos; + item); &#125;, this); &#125;&#125;o.f()// hello a1// hello a2 （3）避免回调函数中的this 回调函数中的this往往会改变指向，最好避免使用。1234567var o = new Object();o.f = function () &#123; console.log(this === o);&#125;o.f() // true 上面代码表示，如果调用o对象的f方法，其中的this就是指向o对象。 但是，如果将f方法指定给某个按钮的click事件，this的指向就变了。1$(&apos;#button&apos;).on(&apos;click&apos;, o.f); 点击按钮以后，控制台会显示false。原因是此时this不再指向o对象，而是指向按钮的DOM对象，因为f方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。 为了解决这个问题，可以采用下面的一些方法对this进行绑定，也就是使得this固定指向某个对象，减少不确定性。 4.绑定 this 的方法this的动态切换，固然为JavaScript创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript提供了call、apply、bind这三个方法，来切换/固定this的指向。 4.1function.prototype.call()函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。12345678var obj = &#123;&#125;;var f = function () &#123; return this;&#125;;f() === this // truef.call(obj) === obj // true 上面代码中，在全局环境运行函数f时，this指向全局环境；call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。 call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。123456789101112var n = 123;var obj = &#123; n: 456 &#125;;function a() &#123; console.log(this.n);&#125;a.call() // 123a.call(null) // 123a.call(undefined) // 123a.call(window) // 123a.call(obj) // 456 上面代码中，a函数中的this关键字，如果指向全局对象，返回结果为123。如果使用call方法将this关键字指向obj对象，返回结果为456。可以看到，如果call方法没有参数，或者参数为null或undefined，则等同于指向全局对象。 如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。123456var f = function () &#123; return this;&#125;;f.call(5)// Number &#123;[[PrimitiveValue]]: 5&#125; 上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。 call方法还可以接受多个参数。1func.call(thisValue, arg1, arg2, ...) call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。12345function add(a, b) &#123; return a + b;&#125;add.call(this, 1, 2) // 3 上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。 call方法的一个应用是调用对象的原生方法。12345678910var obj = &#123;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // false// 覆盖掉继承的 hasOwnProperty 方法obj.hasOwnProperty = function () &#123; return true;&#125;;obj.hasOwnProperty(&apos;toString&apos;) // trueObject.prototype.hasOwnProperty.call(obj, &apos;toString&apos;) // false 上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个方法，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。 4.2function.prototype.apply()apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。1func.apply(thisValue, [arg1, arg2, ...]) apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。 请看下面的例子。123456function f(x,y)&#123; console.log(x+y);&#125;f.call(null,1,1) // 2f.apply(null,[1,1]) // 2 上面的f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。 利用这一点，可以做一些有趣的应用。 （1）找出数组最大元素 JavaScript不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。1234var a = [10, 2, 4, 15, 9];Math.max.apply(null, a)// 15 （2）将数组的空元素变为undefined 通过apply方法，利用Array构造函数将数组的空元素变成undefined。12Array.apply(null, [&quot;a&quot;,,&quot;b&quot;])// [ &apos;a&apos;, undefined, &apos;b&apos; ] 空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。因此，遍历内部元素的时候，会得到不同的结果。1234567891011121314var a = [&apos;a&apos;, , &apos;b&apos;];function print(i) &#123; console.log(i);&#125;a.forEach(print)// a// bArray.apply(null, a).forEach(print)// a// undefined// b （3）转换类似数组的对象 另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。1234567891011Array.prototype.slice.apply(&#123;0:1,length:1&#125;)// [1]Array.prototype.slice.apply(&#123;0:1&#125;)// []Array.prototype.slice.apply(&#123;0:1,length:2&#125;)// [1, undefined]Array.prototype.slice.apply(&#123;length:1&#125;)// [undefined] 上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。 （4）绑定回调函数的对象 上一节按钮点击事件的例子，可以改写成123456789101112var o = new Object();o.f = function () &#123; console.log(this === o);&#125;var f = function ()&#123; o.f.apply(o); // 或者 o.f.call(o);&#125;;$(&apos;#button&apos;).on(&apos;click&apos;, f); 点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法。 4.3function.prototype.bind()bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。12345var d = new Date();d.getTime() // 1481869925657var print = d.getTime;print() // Uncaught TypeError: this is not a Date object. 上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。 bind方法可以解决这个问题，让log方法绑定console对象。12var print = d.getTime.bind(d);print() // 1481869925657 上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。 下面是一个更清晰的例子。12345678910var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;counter.count // 0counter.inc()counter.count // 1 上面代码中，counter.inc内部的this，默认指向counter对象。如果将这个方法赋值给另一个变量，就会出错。1234567891011var counter = &#123; count: 0, inc: function () &#123; this.count++; &#125;&#125;;var func = counter.inc;func();counter.count // 0count // NaN 上面代码中，函数func是在全局环境中运行的，这时inc内部的this指向顶层对象window，所以counter.count是不会变的，反而创建了一个全局变量count。因为window.count原来等于undefined，进行递增运算后undefined++就等于NaN。 为了解决这个问题，可以使用this方法，将inc内部的this绑定到counter对象。123var func = counter.inc.bind(counter);func();counter.count // 1 上面代码中，bind方法将inc方法绑定到counter以后，再运行func就会得到正确结果。 this绑定到其他对象也是可以的。123456var obj = &#123; count: 100&#125;;var func = counter.inc.bind(obj);func();obj.count // 101 上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。 bind比call方法和apply方法更进一步的是，除了绑定this以外，还可以绑定原函数的参数。12345678910111213var add = function (x, y) &#123; return x * this.m + y * this.n;&#125;var obj = &#123; m: 2, n: 2&#125;;var newAdd = add.bind(obj, 5);newAdd(5)// 20 上面代码中，bind方法除了绑定this对象，还将add函数的第一个参数x绑定成5，然后返回一个新函数newAdd，这个函数只要再接受一个参数y就能运行了。 如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（在浏览器中为window）。123456function add(x, y) &#123; return x + y;&#125;var plus5 = add.bind(null, 5);plus5(10) // 15 上面代码中，函数add内部并没有this，使用bind方法的主要目的是绑定参数x，以后每次运行新函数plus5，就只需要提供另一个参数y就够了。而且因为add内部没有this，所以bind的第一个参数是null，不过这里如果是其他对象，也没有影响。 对于那些不支持bind方法的老式浏览器，可以自行定义bind方法。12345678910if(!(&apos;bind&apos; in Function.prototype))&#123; Function.prototype.bind = function()&#123; var fn = this; var context = arguments[0]; var args = Array.prototype.slice.call(arguments, 1); return function()&#123; return fn.apply(context, args); &#125; &#125;&#125; bind方法有一些使用注意点。 （1）每一次返回一个新函数 bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。1element.addEventListener(&apos;click&apos;, o.m.bind(o)); 上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。1element.removeEventListener(&apos;click&apos;, o.m.bind(o)); 正确的方法是写成下面这样：1234var listener = o.m.bind(o);element.addEventListener(&apos;click&apos;, listener);// ...element.removeEventListener(&apos;click&apos;, listener); （2）结合回调函数使用 回调函数是JavaScript最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。1234567891011121314var counter = &#123; count: 0, inc: function () &#123; &apos;use strict&apos;; this.count++; &#125;&#125;;function callIt(callback) &#123; callback();&#125;callIt(counter.inc)// TypeError: Cannot read property &apos;count&apos; of undefined 上面代码中，counter.inc方法被当作回调函数，传入了callIt，调用时其内部的this指向callIt运行时所在的对象，即顶层对象window，所以得不到预想结果。注意，上面的counter.inc方法内部使用了严格模式，在该模式下，this指向顶层对象时会报错，一般模式不会。 解决方法就是使用bind方法，将counter.inc绑定counter。12callIt(counter.inc.bind(counter));counter.count // 1 还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。123456789101112var obj = &#123; name: &apos;张三&apos;, times: [1, 2, 3], print: function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;); &#125;&#125;;obj.print()// 没有任何输出 上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this === window); &#125;);&#125;;obj.print()// true// true// true 解决这个问题，也是通过bind方法绑定this。12345678910obj.print = function () &#123; this.times.forEach(function (n) &#123; console.log(this.name); &#125;.bind(this));&#125;;obj.print()// 张三// 张三// 张三 （3）结合call方法使用 利用bind方法，可以改写一些JavaScript原生方法的使用形式，以数组的slice方法为例。1234567[1, 2, 3].slice(0, 1)// [1]// 等同于Array.prototype.slice.call([1, 2, 3], 0, 1)// [1] 上面的代码中，数组的slice方法从[1, 2, 3]里面，按照指定位置和长度切分出另一个数组。这样做的本质是在[1, 2, 3]上面调用Array.prototype.slice方法，因此可以用call方法表达这个过程，得到同样的结果。 call方法实质上是调用Function.prototype.call方法，因此上面的表达式可以用bind方法改写。123var slice = Function.prototype.call.bind(Array.prototype.slice);slice([1, 2, 3], 0, 1) // [1] 可以看到，利用bind方法，将[1, 2, 3].slice(0, 1)变成了slice([1, 2, 3], 0, 1)的形式。这种形式的改变还可以用于其他数组方法。123456789var push = Function.prototype.call.bind(Array.prototype.push);var pop = Function.prototype.call.bind(Array.prototype.pop);var a = [1 ,2 ,3];push(a, 4)a // [1, 2, 3, 4]pop(a)a // [1, 2, 3] 如果再进一步，将Function.prototype.call方法绑定到Function.prototype.bind对象，就意味着bind的调用形式也可以被改写。123456789function f() &#123; console.log(this.v);&#125;var o = &#123; v: 123 &#125;;var bind = Function.prototype.call.bind(Function.prototype.bind);bind(f, o)() // 123 上面代码表示，将Function.prototype.call方法绑定Function.prototype.bind以后，bind方法的使用形式从f.bind(o)，变成了bind(f, o)。","categories":[],"tags":[{"name":"-面向对象编程","slug":"面向对象编程","permalink":"http://yoursite.com/tags/面向对象编程/"}]},{"title":"面向对象编程-prototype 对象","slug":"面向对象编程-prototype-对象","date":"2016-10-04T10:30:38.000Z","updated":"2017-03-06T09:21:01.340Z","comments":true,"path":"2016/10/04/面向对象编程-prototype-对象/","link":"","permalink":"http://yoursite.com/2016/10/04/面向对象编程-prototype-对象/","excerpt":"目录 概述 构造函数的缺点 prototype属性的作用 原型链 constructor属性 instanceof运算符 Object.getPrototypeOf() Object.setPrototypeOf() Object.create() Object.prototype.isPrototypeOf() Object.prototype.proto 获取原型对象方法的比较大部分面向对象的编程语言，都是以“类”（class）作为对象体系的语法基础。JavaScript语言不是如此，它的面向对象编程基于“原型对象”。 1.概述1.1构造函数的缺点JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);cat1.name // &apos;大毛&apos;cat1.color // &apos;白色&apos;","text":"目录 概述 构造函数的缺点 prototype属性的作用 原型链 constructor属性 instanceof运算符 Object.getPrototypeOf() Object.setPrototypeOf() Object.create() Object.prototype.isPrototypeOf() Object.prototype.proto 获取原型对象方法的比较大部分面向对象的编程语言，都是以“类”（class）作为对象体系的语法基础。JavaScript语言不是如此，它的面向对象编程基于“原型对象”。 1.概述1.1构造函数的缺点JavaScript通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。123456789function Cat (name, color) &#123; this.name = name; this.color = color;&#125;var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);cat1.name // &apos;大毛&apos;cat1.color // &apos;白色&apos; 上面代码的Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象都会生成这两个属性。但是，这样做是对系统资源的浪费，因为同一个构造函数的对象实例之间，无法共享属性。12345678910111213function Cat(name, color) &#123; this.name = name; this.color = color; this.meow = function () &#123; console.log(&apos;mew, mew, mew...&apos;); &#125;;&#125;var cat1 = new Cat(&apos;大毛&apos;, &apos;白色&apos;);var cat2 = new Cat(&apos;二毛&apos;, &apos;黑色&apos;);cat1.meow === cat2.meow// false 上面代码中，cat1和cat2是同一个构造函数的实例。但是，它们的meow方法是不一样的，就是说每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。 1.2prototype属性的作用JavaScript的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象。 原型对象上的所有属性和方法，都能被派生对象共享。这就是JavaScript继承机制的基本设计。 通过构造函数生成实例对象时，会自动为实例对象分配原型对象。每一个构造函数都有一个prototype属性，这个属性就是实例对象的原型对象。1234567891011function Animal (name) &#123; this.name = name;&#125;Animal.prototype.color = &apos;white&apos;;var cat1 = new Animal(&apos;大毛&apos;);var cat2 = new Animal(&apos;二毛&apos;);cat1.color // &apos;white&apos;cat2.color // &apos;white&apos; 上面代码中，构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。结果，实例对象都能读取该属性。 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。1234Animal.prototype.color = &apos;yellow&apos;;cat1.color // &quot;yellow&quot;cat2.color // &quot;yellow&quot; 上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。1234cat1.color = &apos;black&apos;;cat2.color // &apos;yellow&apos;Animal.prototype.color // &quot;yellow&quot;; 上面代码中，实例对象cat1的color属性改为black，就使得它不再去原型对象读取color属性，后者的值依然为yellow。 总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的含义，而实例对象可以视作从原型对象衍生出来的子对象。123Animal.prototype.walk = function () &#123; console.log(this.name + &apos; is walking&apos;);&#125;; 上面代码中，Animal.prototype对象上面定义了一个walk方法，这个方法将可以在所有Animal实例对象上面调用。 由于JavaScript的所有对象都有构造函数，而所有构造函数都有prototype属性（其实是所有函数都有prototype属性），所以所有对象都有自己的原型对象。 1.3原型链对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。那么，Object.prototype对象有没有它的原型呢？回答可以是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。12Object.getPrototypeOf(Object.prototype)// null 上面代码表示，Object.prototype对象的原型是null，由于null没有任何属性，所以原型链到此为止。 “原型链”的作用是，读取对象的某个属性时，JavaScript引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。 如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overiding）。 需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。 举例来说，如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法。12345678910var MyArray = function () &#123;&#125;;MyArray.prototype = new Array();MyArray.prototype.constructor = MyArray;var mine = new MyArray();mine.push(1, 2, 3);mine.length // 3mine instanceof Array // true 上面代码中，mine是构造函数MyArray的实例对象，由于MyArray的prototype属性指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。至于最后那行instanceof表达式，我们知道instanceof运算符用来比较一个对象是否为某个构造函数的实例，最后一行就表示mine为Array的实例。 下面的代码可以找出，某个属性到底是原型链上哪个对象自身的属性。123456function getDefiningObject(obj, propKey) &#123; while (obj &amp;&amp; !&#123;&#125;.hasOwnProperty.call(obj, propKey)) &#123; obj = Object.getPrototypeOf(obj); &#125; return obj;&#125; 1.4constructor属性prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。1234function P() &#123;&#125;P.prototype.constructor === P// true 由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承。1234567891011function P() &#123;&#125;var p = new P();p.constructor// function P() &#123;&#125;p.constructor === P.prototype.constructor// truep.hasOwnProperty(&apos;constructor&apos;)// false 上面代码中，p是构造函数P的实例对象，但是p自身没有contructor属性，该属性其实是读取原型链上面的P.prototype.constructor属性。 constructor属性的作用，是分辨原型对象到底属于哪个构造函数。12345function F() &#123;&#125;;var f = new F();f.constructor === F // truef.constructor === RegExp // false 上面代码表示，使用constructor属性，确定实例对象f的构造函数是F，而不是RegExp。 有了constructor属性，就可以从实例新建另一个实例。12345function Constr() &#123;&#125;var x = new Constr();var y = new x.constructor();y instanceof Constr // true 上面代码中，x是构造函数Constr的实例，可以从x.constructor间接调用构造函数。 这使得在实例方法中，调用自身的构造函数成为可能。123Constr.prototype.createCopy = function () &#123; return new this.constructor();&#125;; 这也提供了继承模式的一种实现。1234567function Super() &#123;&#125;function Sub() &#123; Sub.superclass.constructor.call(this);&#125;Sub.superclass = new Super(); 上面代码中，Super和Sub都是构造函数，在Sub内部的this上调用Super，就会形成Sub继承Super的效果。 由于constructor属性是一种原型对象与构造函数的关联关系，所以修改原型对象的时候，务必要小心。1234567function A() &#123;&#125;var a = new A();a instanceof A // truefunction B() &#123;&#125;A.prototype = B.prototype;a instanceof A // false 上面代码中，a是A的实例。修改了A.prototype以后，constructor属性的指向就变了，导致instanceof运算符失真。 所以，修改原型对象时，一般要同时校正constructor属性的指向。123456789101112131415// 避免这种写法C.prototype = &#123; method1: function (...) &#123; ... &#125;, // ...&#125;;// 较好的写法C.prototype = &#123; constructor: C, method1: function (...) &#123; ... &#125;, // ...&#125;;// 好的写法C.prototype.method1 = function (...) &#123; ... &#125;; 上面代码中，避免完全覆盖掉原来的prototype属性，要么将constructor属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证instanceof运算符不会失真。 此外，通过name属性，可以从实例得到构造函数的名称。123function Foo() &#123;&#125;var f = new Foo();f.constructor.name // &quot;Foo&quot; 2.instanceof运算符instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。12var v = new Vehicle();v instanceof Vehicle // true 上面代码中，对象v是构造函数Vehicle的实例，所以返回true。 instanceof运算符的左边是实例对象，右边是构造函数。它的运算实质是检查右边构建函数的原型对象，是否在左边对象的原型链上。因此，下面两种写法是等价的。123v instanceof Vehicle// 等同于Vehicle.prototype.isPrototypeOf(v) 由于instanceof对整个原型链上的对象都有效，因此同一个实例对象，可能会对多个构造函数都返回true。123var d = new Date();d instanceof Date // trued instanceof Object // true 上面代码中，d同时是Date和Object的实例，因此对这两个构造函数都返回true。 instanceof的原理是检查原型链，对于那些不存在原型链的对象，就无法判断。1Object.create(null) instanceof Object // false 上面代码中，Object.create(null)返回的新对象的原型是null，即不存在原型，因此instanceof就认为该对象不是Object的实例。 除了上面这种继承null的特殊情况，JavaScript之中，只要是对象，就有对应的构造函数。因此，instanceof运算符的一个用处，是判断值的类型。1234var x = [1, 2, 3];var y = &#123;&#125;;x instanceof Array // truey instanceof Object // true 上面代码中，instanceof运算符判断，变量x是数组，变量y是对象。 注意，instanceof运算符只能用于对象，不适用原始类型的值。12var s = &apos;hello&apos;;s instanceof String // false 上面代码中，字符串不是String对象的实例（因为字符串不是对象），所以返回false。 此外，undefined和null不是对象，所以instanceOf运算符总是返回false。12undefined instanceof Object // falsenull instanceof Object // false 利用instanceof运算符，还可以巧妙地解决，调用构造函数时，忘了加new命令的问题。123456789function Fubar (foo, bar) &#123; if (this instanceof Fubar) &#123; this._foo = foo; this._bar = bar; &#125; else &#123; return new Fubar(foo, bar); &#125;&#125; 上面代码使用instanceof运算符，在函数体内部判断this关键字是否为构造函数Fubar的实例。如果不是，就表明忘了加new命令。 3.Object.getPrototypeOf()Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。12345678910111213// 空对象的原型是Object.prototypeObject.getPrototypeOf(&#123;&#125;) === Object.prototype// true// 函数的原型是Function.prototypefunction f() &#123;&#125;Object.getPrototypeOf(f) === Function.prototype// true// f 为 F 的实例对象，则 f 的原型是 F.prototypevar f = new F();Object.getPrototypeOf(f) === F.prototype// true 4.Object.setPrototypeOf()Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。 Object.setPrototypeOf方法接受两个参数，第一个是现有对象，第二个是原型对象。123456var a = &#123;x: 1&#125;;var b = Object.setPrototypeOf(&#123;&#125;, a);// 等同于// var b = &#123;__proto__: a&#125;;b.x // 1 上面代码中，b对象是Object.setPrototypeOf方法返回的一个新对象。该对象本身为空、原型为a对象，所以b对象可以拿到a对象的所有属性和方法。b对象本身并没有x属性，但是JavaScript引擎找到它的原型对象a，然后读取a的x属性。 new命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的prototype属性，然后在实例对象上执行构造函数。123456789var F = function () &#123; this.foo = &apos;bar&apos;;&#125;;var f = new F();// 等同于var f = Object.setPrototypeOf(&#123;&#125;, F.prototype);F.call(f); 5.Object.create()Object.create方法用于从原型对象生成新的实例对象，可以替代new命令。 它接受一个对象作为参数，返回一个新对象，后者完全继承前者的属性，即原有对象成为新对象的原型。12345678910var A = &#123; print: function () &#123; console.log(&apos;hello&apos;); &#125;&#125;;var B = Object.create(A);B.print() // helloB.print === A.print // true 上面代码中，Object.create方法在A的基础上生成了B。此时，A就成了B的原型，B就继承了A的所有属性和方法。这段代码等同于下面的代码。12345678910var A = function () &#123;&#125;;A.prototype = &#123; print: function () &#123; console.log(&apos;hello&apos;); &#125;&#125;;var B = new A();B.print === A.prototype.print // true 实际上，Object.create方法可以用下面的代码代替。如果老式浏览器不支持Object.create方法，可以就用这段代码自己部署。1234567if (typeof Object.create !== &apos;function&apos;) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;;&#125; 上面代码表示，Object.create方法实质是新建一个构造函数F，然后让F的prototype属性指向作为原型的对象o，最后返回一个F的实例，从而实现让实例继承o的属性。 下面三种方式生成的新对象是等价的。123var o1 = Object.create(&#123;&#125;);var o2 = Object.create(Object.prototype);var o3 = new Object(); 如果想要生成一个不继承任何属性（比如没有toString和valueOf方法）的对象，可以将Object.create的参数设为null。1234var o = Object.create(null);o.valueOf()// TypeError: Object [object Object] has no method &apos;valueOf&apos; 上面代码表示，如果对象o的原型是null，它就不具备一些定义在Object.prototype对象上面的属性，比如valueOf方法。 使用Object.create方法的时候，必须提供对象原型，否则会报错。12Object.create()// TypeError: Object prototype may only be an Object or null object.create方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。123456var o1 = &#123; p: 1 &#125;;var o2 = Object.create(o1);o1.p = 2;o2.p// 2 上面代码表示，修改对象原型会影响到新生成的对象。 除了对象的原型，Object.create方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到新对象。123456789var o = Object.create(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: &apos;abc&apos;, enumerable: true &#125;&#125;);// 等同于var o = Object.create(&#123;&#125;);o.p1 = 123;o.p2 = &apos;abc&apos;; Object.create方法生成的对象，继承了它的原型对象的构造函数。123456function A() &#123;&#125;var a = new A();var b = Object.create(a);b.constructor === A // trueb instanceof A // true 上面代码中，b对象的原型是a对象，因此继承了a对象的构造函数A。 6.Object.prototype.isPrototypeOf()对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。123456var o1 = &#123;&#125;;var o2 = Object.create(o1);var o3 = Object.create(o2);o2.isPrototypeOf(o3) // trueo1.isPrototypeOf(o3) // true 上面代码表明，只要某个对象处在原型链上，isPrototypeOf都返回true。1234Object.prototype.isPrototypeOf(&#123;&#125;) // trueObject.prototype.isPrototypeOf([]) // trueObject.prototype.isPrototypeOf(/xyz/) // trueObject.prototype.isPrototypeOf(Object.create(null)) // false 上面代码中，由于Object.prototype处于原型链的最顶端，所以对各种实例都返回true，只有继承null的对象除外。 7.Object.prototype.protoproto属性（前后各两个下划线）可以改写某个对象的原型对象。12345var obj = &#123;&#125;;var p = &#123;&#125;;obj.__proto__ = p;Object.getPrototypeOf(obj) === p // true 上面代码通过proto属性，将p对象设为obj对象的原型。 根据语言标准，proto属性只有浏览器才需要部署，其他环境可以没有这个属性，而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用Object.getPrototypeof()（读取）和Object.setPrototypeOf()（设置），进行原型对象的读写操作。 原型链可以用proto很直观地表示。123456789101112131415161718var A = &#123; name: &apos;张三&apos;&#125;;var B = &#123; name: &apos;李四&apos;&#125;;var proto = &#123; print: function () &#123; console.log(this.name); &#125;&#125;;A.__proto__ = proto;B.__proto__ = proto;A.print() // 张三B.print() // 李四 上面代码中，A对象和B对象的原型都是proto对象，它们都共享proto对象的print方法。也就是说，A和B的print方法，都是在调用proto对象的print方法。123A.print === B.print // trueA.print === proto.print // trueB.print === proto.print // true 可以使用Object.getPrototypeOf方法，检查浏览器是否支持proto属性，老式浏览器不支持这个属性。1Object.getPrototypeOf(&#123; __proto__: null &#125;) === null 上面代码将一个对象的proto属性设为null，然后使用Object.getPrototypeOf方法获取这个对象的原型，判断是否等于null。如果当前环境支持proto属性，两者的比较结果应该是true。 8.获取原型对象方法的比较如前所述，proto属性指向当前对象的原型对象，即构造函数的prototype属性。123456var obj = new Object();obj.__proto__ === Object.prototype// trueobj.__proto__ === obj.constructor.prototype// true 上面代码首先新建了一个对象obj，它的proto属性，指向构造函数（Object或obj.constructor）的prototype属性。所以，两者比较以后，返回true。 因此，获取实例对象obj的原型对象，有三种方法。 obj.proto obj.constructor.prototype Object.getPrototypeOf(obj)上面三种方法之中，前两种都不是很可靠。最新的ES6标准规定，proto属性只有浏览器才需要部署，其他环境可以不部署。而obj.constructor.prototype在手动改变原型对象时，可能会失效。12345678var P = function () &#123;&#125;;var p = new P();var C = function () &#123;&#125;;C.prototype = p;var c = new C();c.constructor.prototype === p // false 上面代码中，C构造函数的原型对象被改成了p，结果c.constructor.prototype就失真了。所以，在改变原型对象时，一般要同时设置constructor属性。1234C.prototype = p;C.prototype.constructor = C;c.constructor.prototype === p // true 所以，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。123var o = new Object();Object.getPrototypeOf(o) === Object.prototype// true","categories":[],"tags":[{"name":"-面向对象编程","slug":"面向对象编程","permalink":"http://yoursite.com/tags/面向对象编程/"}]},{"title":"面向对象编程-面向对象编程的模式","slug":"面向对象编程-面向对象编程的模式","date":"2016-10-03T02:30:34.000Z","updated":"2017-03-06T09:18:20.651Z","comments":true,"path":"2016/10/03/面向对象编程-面向对象编程的模式/","link":"","permalink":"http://yoursite.com/2016/10/03/面向对象编程-面向对象编程的模式/","excerpt":"目录 构造函数的继承 多重继承 模块 基本的实现方法 封装私有变量：构造函数的写法 封装私有变量：立即执行函数的写法 模块的放大模式 输入全局变量 参考链接本节介绍JavaScript语言实际编程中，涉及面向对象编程的一些模式。 1.构造函数的继承让一个构造函数继承另一个构造函数，是非常常见的需求。 这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。1234function Sub(value) &#123; Super.call(this); this.prop = value;&#125; 上面代码中，Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。","text":"目录 构造函数的继承 多重继承 模块 基本的实现方法 封装私有变量：构造函数的写法 封装私有变量：立即执行函数的写法 模块的放大模式 输入全局变量 参考链接本节介绍JavaScript语言实际编程中，涉及面向对象编程的一些模式。 1.构造函数的继承让一个构造函数继承另一个构造函数，是非常常见的需求。 这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。1234function Sub(value) &#123; Super.call(this); this.prop = value;&#125; 上面代码中，Sub是子类的构造函数，this是子类的实例。在实例上调用父类的构造函数Super，就会让子类实例具有父类实例的属性。第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。123Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub;Sub.prototype.method = &apos;...&apos;; 上面代码中，Sub.prototype是子类的原型，要将它赋值为Object.create(Super.prototype)，而不是直接等于Super.prototype。否则后面两行对Sub.prototype的操作，会连父类的原型Super.prototype一起修改掉。 另外一种写法是Sub.prototype等于一个父类实例。1Sub.prototype = new Super(); 上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。 举例来说，下面是一个Shape构造函数。12345678910function Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function (x, y) &#123; this.x += x; this.y += y; console.info(&apos;Shape moved.&apos;);&#125;; 我们需要让Rectangle构造函数继承Shape。12345678910111213// 第一步，子类继承父类的实例function Rectangle() &#123; Shape.call(this); // 调用父类构造函数&#125;// 另一种写法function Rectangle() &#123; this.base = Shape; this.base();&#125;// 第二步，子类继承父类的原型Rectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle; 采用这样的写法以后，instanceof运算符会对子类和父类的构造函数，都返回true。12345var rect = new Rectangle();rect.move(1, 1) // &apos;Shape moved.&apos;rect instanceof Rectangle // truerect instanceof Shape // true 上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。1234ClassB.prototype.print = function() &#123; ClassA.prototype.print.call(this); // some code&#125; 上面代码中，子类B的print方法先调用父类A的print方法，再部署自己的代码。这就等于继承了父类A的print方法。 2.多重继承JavaScript不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。1234567891011121314151617function M1() &#123; this.hello = &apos;hello&apos;;&#125;function M2() &#123; this.world = &apos;world&apos;;&#125;function S() &#123; M1.call(this); M2.call(this);&#125;S.prototype = M1.prototype;var s = new S();s.hello // &apos;hello&apos;s.world // &apos;world&apos; 上面代码中，子类S同时继承了父类M1和M2。当然，从继承链来看，S只有一个父类M1，但是由于在S的实例上，同时执行M1和M2的构造函数，所以它同时继承了这两个类的方法。 3.模块随着网站逐渐变成”互联网应用程序”，嵌入网页的JavaScript代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者不得不使用软件工程的方法，管理网页的业务逻辑。 JavaScript模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。 但是，JavaScript不是一种模块化编程语言，ES5不支持”类”（class），更遑论”模块”（module）了。ES6正式支持”类”和”模块”，但还没有成为主流。JavaScript社区做了很多努力，在现有的运行环境中，实现模块的效果。 3.1基本的实现方法模块是实现特定功能的一组属性和方法的封装。 只要把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。1234567function m1() &#123; //...&#125;function m2() &#123; //...&#125; 上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。 这种做法的缺点很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 为了解决上面的缺点，可以把模块写成一个对象，所有的模块成员都放到这个对象里面。123456789var module1 = new Object(&#123; _count : 0, m1 : function ()&#123; //... &#125;, m2 : function ()&#123; //... &#125;&#125;); 上面的函数m1和m2，都封装在module1对象里。使用的时候，就是调用这个对象的属性。1module1.m1(); 但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。1module1._count = 5; 3.2封装私有变量：构造函数的写法我们可以利用构造函数，封装私有变量。123456789101112function StringBuilder() &#123; var buffer = []; this.add = function (str) &#123; buffer.push(str); &#125;; this.toString = function () &#123; return buffer.join(&apos;&apos;); &#125;;&#125; 这种方法将私有变量封装在构造函数中，违反了构造函数与实例对象相分离的原则。并且，非常耗费内存。12345678910111213function StringBuilder() &#123; this._buffer = [];&#125;StringBuilder.prototype = &#123; constructor: StringBuilder, add: function (str) &#123; this._buffer.push(str); &#125;, toString: function () &#123; return this._buffer.join(&apos;&apos;); &#125;&#125;; 这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。 3.3封装私有变量：立即执行函数的写法使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。12345678910111213var module1 = (function () &#123; var _count = 0; var m1 = function () &#123; //... &#125;; var m2 = function () &#123; //... &#125;; return &#123; m1 : m1, m2 : m2 &#125;;&#125;)(); 使用上面的写法，外部代码无法读取内部的_count变量。1console.info(module1._count); //undefined 上面的module1就是JavaScript模块的基本写法。下面，再对这种写法进行加工。 3.4模块的放大模式如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。123456var module1 = (function (mod)&#123; mod.m3 = function () &#123; //... &#125;; return mod;&#125;)(module1); 上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。 在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。1234var module1 = ( function (mod)&#123; //... return mod;&#125;)(window.module1 || &#123;&#125;); 与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。 3.5输入全局变量独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。 为了在模块内部调用全局变量，必须显式地将其他变量输入模块。123var module1 = (function ($, YAHOO) &#123; //...&#125;)(jQuery, YAHOO); 上面的module1模块需要使用jQuery库和YUI库，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。 立即执行函数还可以起到命名空间的作用。123456789101112131415161718192021(function($, window, document) &#123; function go(num) &#123; &#125; function handleEvents() &#123; &#125; function initialize() &#123; &#125; function dieCarouselDie() &#123; &#125; //attach to the global scope window.finalCarousel = &#123; init : initialize, destroy : dieCouraselDie &#125;&#125;)( jQuery, window, document ); 上面代码中，finalCarousel对象输出到全局，对外暴露init和destroy接口，内部方法go、handleEvents、initialize、dieCarouselDie都是外部无法调用的。","categories":[],"tags":[{"name":"-面向对象编程","slug":"面向对象编程","permalink":"http://yoursite.com/tags/面向对象编程/"}]},{"title":"面向对象编程-Object 对象与继承","slug":"面向对象编程-Object-对象与继承","date":"2016-10-02T01:08:34.000Z","updated":"2017-03-06T09:20:52.038Z","comments":true,"path":"2016/10/02/面向对象编程-Object-对象与继承/","link":"","permalink":"http://yoursite.com/2016/10/02/面向对象编程-Object-对象与继承/","excerpt":"目录 Object.getOwnPropertyNames() Object.prototype.hasOwnProperty() in 运算符和 for…in 循环 对象的拷贝 参考链接通过原型链，对象的属性分成两种：自身的属性和继承的属性。JavaScript 语言在Object对象上面，提供了很多相关方法，来处理这两种不同的属性。 1.Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。12Object.getOwnPropertyNames(Date)// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;] 上面代码中，Object.getOwnPropertyNames方法返回Date所有自身的属性名。","text":"目录 Object.getOwnPropertyNames() Object.prototype.hasOwnProperty() in 运算符和 for…in 循环 对象的拷贝 参考链接通过原型链，对象的属性分成两种：自身的属性和继承的属性。JavaScript 语言在Object对象上面，提供了很多相关方法，来处理这两种不同的属性。 1.Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。12Object.getOwnPropertyNames(Date)// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;] 上面代码中，Object.getOwnPropertyNames方法返回Date所有自身的属性名。对象本身的属性之中，有的是可以枚举的（enumerable），有的是不可以枚举的，Object.getOwnPropertyNames方法返回所有键名。只获取那些可以枚举的属性，使用Object.keys方法。1Object.keys(Date) // [] 2.Object.prototype.hasOwnProperty()对象实例的hasOwnProperty方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。12345Date.hasOwnProperty(&apos;length&apos;)// trueDate.hasOwnProperty(&apos;toString&apos;)// false hasOwnProperty方法是JavaScript之中唯一一个处理对象属性时，不会遍历原型链的方法。 3.in 运算符和 for…in 循环in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。12&apos;length&apos; in Date // true&apos;toString&apos; in Date // true in运算符常用于检查一个属性是否存在。 获得对象的所有可枚举属性（不管是自身的还是继承的），可以使用for…in循环。123456789var o1 = &#123;p1: 123&#125;;var o2 = Object.create(o1, &#123; p2: &#123; value: &quot;abc&quot;, enumerable: true &#125;&#125;);for (p in o2) &#123;console.info(p);&#125;// p2// p1 为了在for…in循环中获得对象自身的属性，可以采用hasOwnProperty方法判断一下。12345for ( var name in object ) &#123; if ( object.hasOwnProperty(name) ) &#123; /* loop code */ &#125;&#125; 获得对象的所有属性（不管是自身的还是继承的，以及是否可枚举），可以使用下面的函数。12345678910function inheritedPropertyNames(obj) &#123; var props = &#123;&#125;; while(obj) &#123; Object.getOwnPropertyNames(obj).forEach(function(p) &#123; props[p] = true; &#125;); obj = Object.getPrototypeOf(obj); &#125; return Object.getOwnPropertyNames(props);&#125; 上面代码依次获取obj对象的每一级原型对象“自身”的属性，从而获取Obj对象的“所有”属性，不管是否可遍历。 下面是一个例子，列出Date对象的所有属性。12345678910111213141516171819202122232425inheritedPropertyNames(Date)// [// &quot;caller&quot;,// &quot;constructor&quot;,// &quot;toString&quot;,// &quot;UTC&quot;,// &quot;call&quot;,// &quot;parse&quot;,// &quot;prototype&quot;,// &quot;__defineSetter__&quot;,// &quot;__lookupSetter__&quot;,// &quot;length&quot;,// &quot;arguments&quot;,// &quot;bind&quot;,// &quot;__lookupGetter__&quot;,// &quot;isPrototypeOf&quot;,// &quot;toLocaleString&quot;,// &quot;propertyIsEnumerable&quot;,// &quot;valueOf&quot;,// &quot;apply&quot;,// &quot;__defineGetter__&quot;,// &quot;name&quot;,// &quot;now&quot;,// &quot;hasOwnProperty&quot;// ] 4.对象的拷贝如果要拷贝一个对象，需要做到下面两件事情。 确保拷贝后的对象，与原对象具有同样的prototype原型对象。 确保拷贝后的对象，与原对象具有同样的属性。 下面就是根据上面两点，编写的对象拷贝的函数。123456789101112131415function copyObject(orig) &#123; var copy = Object.create(Object.getPrototypeOf(orig)); copyOwnPropertiesFrom(copy, orig); return copy;&#125;function copyOwnPropertiesFrom(target, source) &#123; Object .getOwnPropertyNames(source) .forEach(function(propKey) &#123; var desc = Object.getOwnPropertyDescriptor(source, propKey); Object.defineProperty(target, propKey, desc); &#125;); return target;&#125; 5.参考链接[1] Dr. Axel Rauschmayer, JavaScript properties: inheritance and enumerability","categories":[],"tags":[{"name":"-面向对象编程","slug":"面向对象编程","permalink":"http://yoursite.com/tags/面向对象编程/"}]},{"title":"面向对象编程-构造函数与 new 命令","slug":"面向对象编程-构造函数与-new-命令","date":"2016-10-01T02:08:34.000Z","updated":"2017-03-06T09:21:18.358Z","comments":true,"path":"2016/10/01/面向对象编程-构造函数与-new-命令/","link":"","permalink":"http://yoursite.com/2016/10/01/面向对象编程-构造函数与-new-命令/","excerpt":"目录 对象的概念 构造函数 new 命令 基本用法 new命令的原理 new.target虽然不同于传统的面向对象编程语言，但是JavaScript具有很强的面向对象编程能力。本章介绍JavaScript如何进行“面向对象编程”。 1.对象的概念“面向对象编程”（Object Oriented Programming，缩写为OOP）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。","text":"目录 对象的概念 构造函数 new 命令 基本用法 new命令的原理 new.target虽然不同于传统的面向对象编程语言，但是JavaScript具有很强的面向对象编程能力。本章介绍JavaScript如何进行“面向对象编程”。 1.对象的概念“面向对象编程”（Object Oriented Programming，缩写为OOP）是目前主流的编程范式。它的核心思想是将真实世界中各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。传统的过程式编程（procedural programming）由一系列函数或一系列指令组成，而面向对象编程的程序由一系列对象组成。每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活性、代码的可重用性、模块性等特点，容易维护和开发，非常适合多人合作的大型软件项目。 那么，“对象”（object）到底是什么？ 我们从两个层次来理解。 （1）“对象”是单个实物的抽象。 一本书、一辆汽车、一个人都可以是“对象”，一个数据库、一张网页、一个与远程服务器的连接也可以是“对象”。当实物被抽象成“对象”，实物之间的关系就变成了“对象”之间的关系，从而就可以模拟现实情况，针对“对象”进行编程。 （2）“对象”是一个容器，封装了“属性”（property）和“方法”（method）。 所谓“属性”，就是对象的状态；所谓“方法”，就是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，“属性”记录具体是那一种动物，“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 2.构造函数“面向对象编程”的第一步，就是要生成“对象”。 前面说过，“对象”是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后“对象”根据这个模板生成。 典型的面向对象编程语言（比如 C++ 和 Java），存在“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。 JavaScript语言使用构造函数（constructor）作为对象的模板。所谓“构造函数”，就是专门用来生成“对象”的函数。它提供模板，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。 构造函数的写法就是一个普通的函数，但是有自己的特征和用法。123var Vehicle = function () &#123; this.price = 1000;&#125;; 上面代码中，Vehicle就是构造函数，它提供模板，用来生成对象实例。为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个。 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必需用new命令，调用Vehicle函数。 3.new 命令3.1基本用法new命令的作用，就是执行构造函数，返回一个实例对象。123456var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = new Vehicle();v.price // 1000 上面代码通过new命令，让构造函数Vehicle生成一个实例对象，保存在变量v中。这个新生成的实例对象，从构造函数Vehicle继承了price属性。在new命令执行时，构造函数内部的this，就代表了新生成的实例对象，this.price表示实例对象有一个price属性，它的值是1000。 使用new命令时，根据需要，构造函数也可以接受参数。12345var Vehicle = function (p) &#123; this.price = p;&#125;;var v = new Vehicle(500); new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的。12var v = new Vehicle();var v = new Vehicle; 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？ 这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。12345678910var Vehicle = function ()&#123; this.price = 1000;&#125;;var v = Vehicle();v.price// Uncaught TypeError: Cannot read property &apos;price&apos; of undefinedprice// 1000 上面代码中，调用Vehicle构造函数时，忘了加上new命令。结果，price属性变成了全局变量，而变量v变成了undefined。 因此，应该非常小心，避免出现不使用new命令、直接调用构造函数的情况。为了保证构造函数必须与new命令一起使用，一个解决办法是，在构造函数内部使用严格模式，即第一行加上use strict。12345678function Fubar(foo, bar)&#123; &apos;use strict&apos;; this._foo = foo; this._bar = bar;&#125;Fubar()// TypeError: Cannot set property &apos;_foo&apos; of undefined 上面代码的Fubar为构造函数，use strict命令保证了该函数在严格模式下运行。由于在严格模式中，函数内部的this不能指向全局对象，默认等于undefined，导致不加new调用会报错（JavaScript不允许对undefined添加属性）。 另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。 1234567891011function Fubar(foo, bar)&#123; if (!(this instanceof Fubar)) &#123; return new Fubar(foo, bar); &#125; this._foo = foo; this._bar = bar;&#125;Fubar(1, 2)._foo // 1(new Fubar(1, 2))._foo // 1 上面代码中的构造函数，不管加不加new命令，都会得到同样的结果。 3.2new命令的原理使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。 创建一个空对象，作为将要返回的对象实例 将这个空对象的原型，指向构造函数的prototype属性 将这个空对象赋值给函数内部的this关键字 开始执行构造函数内部的代码 也就是说，构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造”为需要的样子。 如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。1234567var Vehicle = function () &#123; this.price = 1000; return 1000;&#125;;(new Vehicle()) === 1000// false 上面代码中，构造函数Vehicle的return语句返回一个数值。这时，new命令就会忽略这个return语句，返回“构造”后的this对象。 但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。1234567var Vehicle = function ()&#123; this.price = 1000; return &#123; price: 2000 &#125;;&#125;;(new Vehicle()).price// 2000 上面代码中，构造函数Vehicle的return语句，返回的是一个新对象。new命令会返回这个对象，而不是this对象。 另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。12345678function getMessage() &#123; return &apos;this is a message&apos;;&#125;var msg = new getMessage();msg // &#123;&#125;typeof msg // &quot;Object&quot; 上面代码中，getMessage是一个普通函数，返回一个字符串。对它使用new命令，会得到一个空对象。这是因为new命令总是返回一个对象，要么是实例对象，要么是return语句指定的对象。本例中，return语句返回的是字符串，所以new命令就忽略了该语句。 new命令简化的内部流程，可以用下面的代码表示。123456789101112131415function _new(/* 构造函数 */ constructor, /* 构造函数参数 */ param1) &#123; // 将 arguments 对象转为数组 var args = [].slice.call(arguments); // 取出构造函数 var constructor = args.shift(); // 创建一个空对象，继承构造函数的 prototype 属性 var context = Object.create(constructor.prototype); // 执行构造函数 var result = constructor.apply(context, args); // 如果返回结果是对象，就直接返回，则返回 context 对象 return (typeof result === &apos;object&apos; &amp;&amp; result != null) ? result : context;&#125;// 实例var actor = _new(Person, &apos;张三&apos;, 28); 3.3new.target函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。123456function f() &#123; console.log(new.target === f);&#125;f() // falsenew f() // true","categories":[],"tags":[{"name":"-面向对象编程","slug":"面向对象编程","permalink":"http://yoursite.com/tags/面向对象编程/"}]},{"title":"HTML5的兼容性","slug":"HTML5的兼容性","date":"2016-09-02T07:03:56.000Z","updated":"2017-03-06T09:20:45.964Z","comments":true,"path":"2016/09/02/HTML5的兼容性/","link":"","permalink":"http://yoursite.com/2016/09/02/HTML5的兼容性/","excerpt":"因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。HTML5的兼容性 因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。 比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。 这里就需要用到一个方法，document.createElement(); 12var oHeader = document.createElement(&quot;header&quot;);//-&gt; 动态创建一个标签‘header’document.body.appendChild(oHeader)//-&gt; 把header标签动态添加到body中 这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写 1document.createElement(&quot;header&quot;); 这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。","text":"因为在IE8及一下的IE版本是不兼容HTML5的新元素的，所以我们要是用HTML5开发的话，第一个要解决的就是兼容性的问题。HTML5的兼容性 因为HTML5的新元素就是一些新的标签，IE只是不认识这些标签而已，那我们解决的问题就是让IE8一下版本的浏览器认识这些标签，或者说知道他就是一个标签，那么我们就解决了兼容性问题。 比如：header 这个标签在IE8及一下的版本的浏览器中是不认识的，但是我们却可以通过一小段JS代码来创建标签，通过JS来创建的标签浏览器是可以识别的，我们就可以利用这个点来解决兼容性问题。 这里就需要用到一个方法，document.createElement(); 12var oHeader = document.createElement(&quot;header&quot;);//-&gt; 动态创建一个标签‘header’document.body.appendChild(oHeader)//-&gt; 把header标签动态添加到body中 这样添加以后我们就可以在IE8下使用header标签了。但是，我们不确定我们的每一次开发中到底使用多少个header标签，也不确定具体要什么时候使用，如果说我们每一次使用的时候都写一小段JS代码来动态创建和动态添加的话，那就会很耗性能，所以我们只需要在最开始告诉浏览器一声，我创建了一个header标签就可以，至于什么时候用浏览器你就别管了，反正只要出现了这个标签你知道他是什么，会渲染他就可以了，我们就可以这样写 1document.createElement(&quot;header&quot;); 这样就可以了，以后你再使用header标签的时候，浏览器就会知道，他是一个标签，我就按照标签的标准来渲染他就行了。但是第二个问题出现了，那就是我们也不知道我会在这次开发中都使用到哪些个HTML5的标签，那么我们就把每一个HTML5标签都声明一遍就可以了。 这里就不用我们自己来写了，只需要引入一个JS文件就可以了。就是 “html5shiv.min” 这个文件，里面已经帮我们把所有的都写好了，就不用我们每回自己写了。 这个时候出现了第三个问题，那就是我们引入了这个JS文件以后，那么不管这个浏览器是不是兼容HTML5标签，我们都声明了一遍，也就是说我们这一段JS代码都运行了，当然，这样做是没有问题的，可是这样对于已经可以兼容HTML5的浏览器来说就是浪费了，虽然这个文件很小，但是也会浪费一定的性能，作为一个开发人员来说，没一个KB的性能都是能省就省，尽量不出现一个多余的KB。所以，我们就只要让这个JS文件在IE8及以下版本的浏览器中运行就行了，这个时候我们就需要一种方法：123&lt;!--[if lte IE 8]&gt;这个注释是只属于IE的，也就是说只有IE浏览器才认识&lt;![endif]--&gt; 这个注释的意思是，当浏览器是IE8及以下的版本的时候，才执行中间的代码。 123&lt;!--[if lte IE 8]&gt;&lt;script&gt;alert(123)&lt;/script&gt;&lt;![endif]--&gt; 只有在IE8及一下版本的浏览器中，才会执行这个“alert(123)”这个命令，而其他的浏览器不会执行这一段代码。 所以我们可以用这个方法来引入刚才那段JS代码 123&lt;!--[if lte IE 8]&gt;&lt;script src=&quot;./html5shiv.min&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 这样就可以做到只在不兼容HTML5的浏览器中进行声明，而兼容的浏览器则直接跳过，这样做即解决了兼容性问题，也进行了性能优化。 微数据 微数据说白了就是一种对于权重的增加。比如我们在开发每一个网站的时候都会把这个网站的logo写在一个h1标签中，是为了增加权重，让爬虫在抓去的时候能够更好的抓到需要的东西，其实也就是为了语义性更强。 而微数据就是在一个页面制作的时候，对于人物，事件和评论等一些内容，不仅要让用户在看的时候知道这个就是人物，那个就是评论，也需要让搜索引擎和一些辅助的设备知道，而现在的智能设备没有达到这种高度，就需要我们开发者使用一些特定的标签或者属性来达到想要的效果。所以说微数据就是为了方便机器识别而产生的东西。 对于一个人物介绍来说，我们以前这样写： 12345&lt;div&gt;我是传智播客，我的个人首页是：&lt;a href=&quot;http://www.itcast.cn/&quot;&gt;www.itcast.cn&lt;/a&gt;我是全国最大的IT人才培训基地&lt;/div&gt; 而我们有微数据写的话，就是： 12345&lt;div itemscope itemtype=&quot;http://data-vocabulary.org/Person&quot;&gt; 我是&lt;span itemprop=&quot;name&quot;&gt;传智播客&lt;/span&gt;，我的个人首页是： &lt;a href=&quot;http://www.itcast.cn/&quot; itemprop=&quot;url&quot;&gt;www.itcast.cn&lt;/a&gt; 我是&lt;span itemprop=&quot;title&quot;&gt;全国最大&lt;/span&gt;的，&lt;span itemprop=&quot;affiliation&quot;&gt;IT人才&lt;/span&gt;培训基地。&lt;/div&gt; 虽然这个看起来复杂了，HTML代码量确实增加则，但这是我们对于具体语义性增强的方法。 1234itemscope 这个属性是让div这个标签成为了一个微数据项，而包含这个属性的标签和其所有的后代元素变成了一个整体。itemtype 后面的值是一个URL地址，这个地址是对所有的“itemprop”后面的值的含义的一个解释。itemprop=&quot;name&quot; 是指关键词的意思。。。。。。。 这个在实际开发中，因为除了特定的环境下一般不使用，所以了解一下就可以了。 WAI-ARIA WAI-ARIA是指无障碍的网页应用。主要是应用于网页的辅助阅读设备，比如屏幕阅读器。比如，在网页上有一个弹出框，我们普通人是可以一眼就看到，这是一个弹出框，但是对于盲人来说，怎么能知道这个是个弹出框呢： 1&lt;div role=&quot;alertdialog&quot;&gt;&lt;/div&gt; 这样就是告诉了这些辅助设备，这个是一个弹出框。 这些还是使用的不太多的，所以了解一下就好。","categories":[],"tags":[{"name":"-html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"}]},{"title":"CSS3介绍","slug":"CSS3介绍","date":"2016-07-02T12:14:26.000Z","updated":"2017-03-06T09:20:25.411Z","comments":true,"path":"2016/07/02/CSS3介绍/","link":"","permalink":"http://yoursite.com/2016/07/02/CSS3介绍/","excerpt":"在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 CSS3的现状 1、浏览器支持程度差，需要添加私有前缀 2、移动端支持优于PC端 3、不断改进中 4、应用相对广泛 如何对待 1、坚持渐进增强原则 2、考虑用户群体 3、遵照产品的方案 4、听Boss的","text":"在CSS2基础上，增强或新增了许多特性， 弥补了CSS2的众多不足之处，使得Web开发变得更为高效和便捷。 CSS3的现状 1、浏览器支持程度差，需要添加私有前缀 2、移动端支持优于PC端 3、不断改进中 4、应用相对广泛 如何对待 1、坚持渐进增强原则 2、考虑用户群体 3、遵照产品的方案 4、听Boss的 css3选择器属性选择器 a[href]:a标签中含有href属性的所有标签a[href=&quot;1.pm4&quot;]:a标签中含有href=”1.mp4”的标签a[href^=&quot;a&quot;]:a标签中有href属性并且以a字母开头的所有标签a[href$=&quot;d&quot;]:a标签中有href属性并且以d字母结束的所有标签a[href*=&quot;g&quot;]:a标签中有href属性并且g字母的所有标签css中的选择器和jQuery的选择器有什么相同的地方和不同的地方？css中的选择器：选择相应的dom，对其样式进行操作， jQuery中的选择器主要是为了选择响应的dom 对其行为的操作。 伪类选择器:empty伪类选择器:target伪类选择器:not伪类选择器 伪元素选择器 ::before&amp;::after伪元素选择器：是一对儿，通过css往网页中新增内容（不是html中的内容，但是可以正常显示）。::first-letter伪元素选择器 ：第一个字母::first-line伪元素选择器：第一行::section伪元素选择器：选择的区域 单冒号和双冒号的区别 单冒号(:)用于CSS2伪类，双冒号(::)用于CSS3伪元素。双冒号和单冒号的作用是一样的；如果你的网站只需要兼容webkit、firefox、opera等浏览器，建议对于伪元素采用双冒号的写法，如果不得不兼容IE浏览器，还是用CSS2的单冒号写法比较安全。 文字阴影 text-shadow:-3px -3px 5px #000, 6px 6px 5px red;参数：一组四个，可以存在多组； 第一个：水平偏移量 第二个：垂直偏移量 第三个：阴影的模糊度，不能为负值 第三个：颜色，通常是十六进制表示文字阴影案例 边框边框圆角 border-radius:200px 200px 200px 200px;参数：原点、半径1-4个，可以不一样； 可分别设置长、短半径，以“/”进行分隔，遵循“1，2，3，4”规则，“/”前面的1~4个用来设置横轴半径（分别对应横轴1、2、3、4位置 ），“/”后面1~4个参数用来设置纵轴半径（分别对应纵轴1、2、3、4位置 ） 正圆 border-radius:50%正方形边长的一半(50%)，并且只写一个参数就可以。 椭圆border-radius:可以写具体的数值，也可以用百分数表示，最好写一个参数。 边框阴影border-shadow 1、水平偏移量 正值向右 负值向左； 2、垂直偏移量 正值向下 负值向上； 3、模糊度是不能为负值； 4、inset可以设置内阴影；注意:设置边框阴影不会改变盒子的大小，即不会影响其兄弟元素的布局。可以设置多重边框阴影，实现更好的效果，增强立体感。 边框图片(了解)border-image:设置的图片将会被“切割”成九宫格形式，然后进行设置. “切割”完成后生成虚拟的9块图形，然后按对应位置设置背景其中四个角位置、形状保持不变，中心位置水平垂直两个方向平铺。 repeat和round的区别round 会自动调整尺寸，完整显示边框图片。repeat 单纯平铺多余部分，会被“裁切”而不能完整显示。 更改裁切尺寸background-slice: 34 36 27 27;分别设置裁切 盒模型 CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。可以分成两种情况：1、box-sizing: border-box 计算方式为content = width – border - padding2、box-sizing: content-box 计算方式为content = width兼容性比较好","categories":[],"tags":[{"name":"-css3","slug":"css3","permalink":"http://yoursite.com/tags/css3/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-04-02T07:03:56.000Z","updated":"2017-03-06T02:44:34.481Z","comments":true,"path":"2016/04/02/hello-world/","link":"","permalink":"http://yoursite.com/2016/04/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}